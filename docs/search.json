[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Basics of Statistics and R",
    "section": "",
    "text": "Preface - Aim and Scope"
  },
  {
    "objectID": "index.html#what-is-this",
    "href": "index.html#what-is-this",
    "title": "Basics of Statistics and R",
    "section": "What is this?",
    "text": "What is this?\nThis is not an exhaustive book featuring deep dives into the history or application of specific statistics concepts, ideas and methods. It is also not meant to be a textbook accompanying a university course - although I might use it in this way in the future.\nInstead, this is meant to be a collection of small texts and examples serving as primers on core statistical concepts, methods and workflows. The aim here is to present the basic ideas (as well as their execution in R) and explain the reasons behind these ideas, in order to give you a general understanding as to what is happening. I will also point you in the right direction if you want to dive deeper.\n\nAren’t there many resources like this already?\nYes, and no. Although a lot of books have been written about the core ideas behind statistical methods, and many web resources about the application of these methods in any given statistical program exist, these suffer from some major drawbacks:\n\nBooks are long and nobody wants to read anymore. I hope that my way of explaining stuff as concise as possible, as well as my way of writing will resonate in a way that many “dry” statistics textbooks simply can’t.\nWhile Andy Field’s (2012) is still a great book on the subject, it was published in 2012 and much of the code used is unfortunately wildly out-of-date. Don’t get me wrong, most of it will still work fine. However, better and more user-friendly ways to work in R have emerged since.\nAt the end of the day statistics is math, and math people love communicating via formulas and mathematical notations. I don’t know about you, but unfortunately my brain shuts off whenever I see more than two mathematical formulas in a text. Therefore, I will try to keep the mathematics to a minimum and instead focus on examples and comparisons to explain ideas.\nHow-To guides tend to focus mainly on the “how” of statistical methods and not on the “why” behind it. While they might make you an expert about anything a given R (Python, …) function may be able to do, you still won’t know when and how to use them - or why you might get certain weird results back. Also, nowadays LLMs can teach you the “how” part probably better than any website ever will.\nMost statistics websites are run by professional website owners. This is not meant as a dig at them - they can do whatever they want - but I personally hate seeing ads and cookie-popups when I just want to find out why my code won’t work. Therefore, you won’t find ads or cookie banners here, because I don’t care who you are. :)"
  },
  {
    "objectID": "index.html#the-core-structure",
    "href": "index.html#the-core-structure",
    "title": "Basics of Statistics and R",
    "section": "The Core Structure",
    "text": "The Core Structure\nThis also means that this isn’t necessarily designed to be read front-to-back. Instead, I would encourage you to jump to a specific subject whenever you encounter it, and work your way from there until the end of your issues.\nHowever, I have still organized the book into subsections that (in my view) link together logically connected subjects and methods, going from simple methods and concepts on towards more complex implementations. However, the sprawling nature of statistical methods and coding means that forcing everything into a linear progression would do more harm than good. Therefore, while you may encounter basic concepts in a given topic (like “Plotting Data” in the main topic “Descriptive Statistics”), you will also find expansions of these contexts in separate topics (in this case “Data Plotting in R”).\nTo emphasize this further, everything that centers on using R, and less on statistical methodology has been organized into it’s own part in the structure. While the numbered parts deal with statistics, part R focuses on using R and RStudio. I would encourage everyone who is not familiar with R (or certain packages I frequently use) to look at this part whenever you’re not sure what I’m doing or why I’m doing things in a certain way - you’ll hopefully find an explanation there.\n\nLast modified: 2023-08-24 13:44, R version 4.3.1\nSource data for this page can be found here.\n\n\n\n\nField, Andy P., Jeremy Miles, and Zoë Field. 2012. Discovering Statistics Using R. London ; Thousand Oaks, Calif: Sage."
  },
  {
    "objectID": "files/1stats_1basics.html",
    "href": "files/1stats_1basics.html",
    "title": "1  The Basic Idea of Statistics",
    "section": "",
    "text": "Last modified: 2023-08-24 12:14, R version 4.3.1\nSource data for this page can be found here."
  },
  {
    "objectID": "files/1stats_2sampling.html",
    "href": "files/1stats_2sampling.html",
    "title": "2  Sampling",
    "section": "",
    "text": "Last modified: 2023-08-24 12:14, R version 4.3.1\nSource data for this page can be found here."
  },
  {
    "objectID": "files/R_ggplot.html#why-ggplot2",
    "href": "files/R_ggplot.html#why-ggplot2",
    "title": "3  Beautiful data visualizations using ggplot2",
    "section": "Why ggplot2?",
    "text": "Why ggplot2?\nEven though base-R already comes with multiple functions and features to visually display information (like the plot() and hist() functions), the results are usually not very nice to look at - especially when you think about publishing them in a more professional setting. ggplot2 is one of multiple packages (see also plot_ly) that aims to make data visualizations easy and nice to look at:\n\ndata(mpg)\n\n# plotting with base-R command plot()\nplot(mpg$displ, mpg$hwy, \n     # additional labels\n     main = \"Engine size - Miles/Gallon plot for different cars\",\n     sub = \"plotted in base-R\", xlab = \"Engine size (litre)\", ylab = \"Miles/Gallon\")\n# plotting with ggplot2 command ggplot() and dplyr-pipes\nmpg %&gt;% mutate(cyl = as.factor(cyl)) %&gt;%\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_smooth(colour = \"dark gray\", fill = \"light gray\") + geom_point(aes(colour = cyl)) + theme_minimal() +\n  # additional labels\n  labs(title = \"Engine size - Miles/Gallon plot for different cars\",\n       subtitle = \"plotted in ggplot2\",\n       x = \"Engine size (litre)\", y = \"Miles/Gallon\", colour = \"# of cylinders\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\nTwo things should be directly noticeable in the plots above: For one, ggplot’s plot is way cleaner and nicer to look at than the base-R plot, with options for colours and additional variables (number of cylinders) as well as measures for tendencies in the data. The other thing to note: ggplot’s command is way more complex and involved to set up than the base-R command.\nThis complexita is by design, as ggplot2 builds upon an underlying and standardized Grammar of Graphics basiert (the GG in ggplot). Luckily, much of what seems like complexities in the code above can be reduced down to the modularity this approach brings with it - and once you understand the core concepts and modules (or the core vocabulary of the “grammar”), you should be able to understand and write your own visualizations in no time. :)"
  },
  {
    "objectID": "files/R_ggplot.html#modularity-be-my-canvas",
    "href": "files/R_ggplot.html#modularity-be-my-canvas",
    "title": "3  Beautiful data visualizations using ggplot2",
    "section": "Modularity: Be my canvas",
    "text": "Modularity: Be my canvas\nggplot2 follows a modular design. This means that the final plot will not be calculated in one step, but instead built up through multiple overlaying partial commands. The amount and design of these commands is entirely up to you, and both the commands you pick as well as their order will impact the final plot. This enables you to build insanely complex plots if you invest the time and energy to learn the underlying ideas and structures.\n\nSetting the stage: ggplot()\nCore of this modular approach is the ggplot() command, which serves two functions: On one hand it specifies that everything following is part of a plot and outlines the general canvas, and on the other it can be used to specify global commands and settings that should be true for the entire plot. If you for example want to use the same core data set for all elements in your plot, you could specify this data set for each element individually, or you could include it in the ggplot() function, where you only have to type it out once.\nTo visualize: Executing an empty ggplot() command produces an empty canvas, in effect only providing a background for your plot (left). If you already include a data set as well as variables (don’t worry, we’ll look at this in detail in a second), you also already get axes overlayed depending on the scaling of your variables:\n\n# empty ggplot function\nggplot()\n# ggplot function with global data and axis specification\nggplot(data = mpg, aes(x = displ, y = hwy))\n\n\n\n\n\n\n\n\n\n\n\nThis specification of global parameters is also great to keep an overview over the variables and options used if you want to use multiple visualizations in the same plot (ex. points and lines as in the example above). On a technical level it doesn’t matter which approach you take, as both lead to the same result:\n\n# plot with local vars for each element\nggplot() + geom_point(aes(x = mpg$displ, y = mpg$hwy)) + geom_smooth(aes(x = mpg$displ, y = mpg$hwy))\n# plot with global vars for the entire plot\nggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSide Notes\n\n\n\n\nAs you can see, if you include parameters in the ggplot() functions, you can use the tidyverse way of giving only column names, whereas the individual functions need a direct reference to the data set used.\nYou can also combine both approaches, for example if you want to use the same data set (specified in global function) but different colour palettes for different elements (specified in the local functions) or if you want on element to use an entirely different data source.\n\n\n\nAs you can see, we can now easily expand our core canvas by chaining further functions with a + at the end of the ggplot() function. The command chain ggplot() + geom_histogram() + labs() would create a canvas (ggplot()), draw a histogram of the specified data on top of it (geom_histogram()) and then overwrite the automatically generated names for parts of the plot with the names specified in labs(). Because each element is evaluated separate from the others, it is important to close all opened brackets before a +!\n\n\nUsed data and aesthetics: aes()\nAs can be seen above, used data and other aesthetic arguments have to be specified within a aes() command nested inside the command for an element (or the global command). Correctly nesting this function is an essential step and usually the primary source of issues if something doesn’t work with your code. The aes() command can take not only variables to display on the x and y axis, but also variables that should be used to define other attributes of the plot, like colour or fill and a whole host of further options.\nHOWEVER: Just because arguments like colour and fill can be specified inside aes(), that doesn’t mean they have to. You can also specify these aspects outside of aes() if you want to set them to a specific value rather than base them on a variable:\n\n# colour inside aes -&gt; colour based on variable\nmpg %&gt;% mutate(cyl = as.factor(cyl)) %&gt;%\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point(aes(colour = cyl)) + theme_minimal() + \n  labs(title = \"Engine size - Miles/Gallon plot for different cars\",\n       x = \"Engine size (litre)\", y = \"Miles/Gallon\", colour = \"# of cylinders\")\n# colour outside aes -&gt; colour takes specified value\nmpg %&gt;% mutate(cyl = as.factor(cyl)) %&gt;%\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point(colour = \"blue\") + theme_minimal() + \n  labs(title = \"Engine size - Miles/Gallon plot for different cars\",\n       x = \"Engine size (litre)\", y = \"Miles/Gallon\", colour = \"# of cylinders\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nTo preempt upcoming confusions: You will get errors when you specify a variable colour outside aes(), but you won’t when you specify a definite colour inside aes(). Instead, code like geom_point(aes(colour = \"blue\")) will make R look for the variable blue in your data - and if that doesn’t exist, it will simply treat all cases as having the same value for this attribute and assign the first colour of the standard colour palette - which is red. So, if you ever wonder why “blue” appears as red in your plot, this might be why.\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nKnowing when to use colour or fill is a whole headache in and of it self and depends on the chosen visualization method. Generally, fill is used for the inside fill of an element, while colour is used for borders and edges - with geom_point() being the most prominent exception and using only the colour attribute for points.\n\n\n\n\nVisualization elements: geom_...\nAs you have seen in the previous examples, geom_...functions build on the defined canvas and offer the meat of data visualization. If you enter “geom_” in RStudio, you will see that the autocomplete function offers you a wide array of different options for plotting your data, from lines up to entire maps.\n\n\n\n\n\n\nImportant\n\n\n\nWhen choosing a visualization element for your plots, always keep an eye on the arguments the associated function takes! Especially bar plots and histograms only take an x variable as input and derive y from frequency distributions of x. Manually specifying y in the geom-function (or the global ggplot-function) will lead to errors and annoyances.\n\n\nIn theory, the modular nature of ggplot2 allows you to stack as many elements on top of each other. However, keep the modular buildup of ggplot in mind: The most frequent element will overlay any element specified prior to it!\n\n# dots after line, dots overlay\nmpg %&gt;% mutate(cyl = as.factor(cyl)) %&gt;%\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_smooth(colour = \"black\", fill = \"dark gray\") + geom_point(aes(colour = cyl)) + theme_minimal() + \n  labs(x = \"Engine size (litre)\", y = \"Miles/Gallon\", colour = \"# of cylinders\")\n# line after dots, line overlays\nmpg %&gt;% mutate(cyl = as.factor(cyl)) %&gt;%\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point(aes(colour = cyl)) + theme_minimal() + geom_smooth(colour = \"black\", fill = \"dark gray\") + \n  labs(x = \"Engine size (litre)\", y = \"Miles/Gallon\", colour = \"# of cylinders\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nOther central building blocks\nAside from geom_... functions, ggplot packs a whole load of additional functions to improve and/or modify the way you display your data. I have already used the labs()function in multiple plots to specify my own names for for axes, legends or the entire plot, rather than the defaults, which are derived from variable names in your input data. Further options using additional functions are scale transformations (using for example scale_x_log10() or scale_y_data()), different colour palettes (ex. scale_colour_gradient() or scale_fill_manual()for custom palettes), as well as overarching design themes for the entire plot, like theme_minimal().\n\n\n\n\n\n\nSide Note\n\n\n\nDon’t know if you’ve noticed, but these functions are available in many different versions for many different use cases. Anything you find under scale_x_... will have an equivalent under scale_y_... depending on which variable you want to transform. Same goes for the other arguments, with scale_colour_... and scale_fill_... containing much of the same functions, only applied in different contexts."
  },
  {
    "objectID": "files/R_ggplot.html#everything-all-at-once---information-overload",
    "href": "files/R_ggplot.html#everything-all-at-once---information-overload",
    "title": "3  Beautiful data visualizations using ggplot2",
    "section": "Everything all at once - information overload",
    "text": "Everything all at once - information overload\nAs I’ve said before, you can tweak a wide array of elements to your liking - I’ve simply focused on colour and fill as I think these will be the two most frequently used elements. But you can go further: Tweak the shape of points, the thickness of lines, the opacity of bars or whatever else you want! Heck, put it all together on one plot and make everything entirely unreadable - but undeniably unique:\n\nmpg %&gt;% mutate(cyl = as.factor(cyl), year = as.factor(year)) %&gt;%\n  ggplot(aes(x = displ, y = hwy)) + # X and Y variable\n  geom_point(aes(alpha = cyl, # opacity based on # of cylinders\n                 shape = year, # year as form for points\n                 colour = fl, # fuel type as colour\n                 size = class # vehicle type as size\n                 )) + \n  geom_text(aes(label = manufacturer), size = 2, nudge_y = 1.5) + # manufacturer as name\n  theme_minimal() + theme(legend.position = \"none\") + \n  labs(title = \"Engine size - Miles/Gallon plot for different cars\",\n       subtitle = \"plotted in ggplot2\",\n       x = \"Engine size (litre)\", y = \"Miles/Gallon\", colour = \"# of cylinders\")"
  },
  {
    "objectID": "files/R_ggplot.html#presentation-and-colours",
    "href": "files/R_ggplot.html#presentation-and-colours",
    "title": "3  Beautiful data visualizations using ggplot2",
    "section": "Presentation and colours",
    "text": "Presentation and colours\nAs you have already seen multiple times by now, you can change basically the entirety of a plot’s presentation and resulting graphics. This can be of great help when it comes to generating plots that present large amounts of data in a readable format. I want to use this short section to highlight two different approaches to make this customization even more powerful:\nFor colours, I very much like using Brewer palettes (use scale_..._brewer(palette=\"Name\") in ggplot) for discrete values and viridis palettes (use scale_..._viridis_c(option=LetterOrName)) for continuous values (viridis can also handle binned or discrete scales with …_b and …_d respectively).\nAlthough I am partial to minimalism and therefore like theme_minimal() a lot, you can also expand the range of available plot themes with something like ggthemes if you like excel too much. You can also create and use your own theme if you like. For an easier time, have a look at the ggCorpIdent package - however, keep in mind that Tufte (2001) is right when he says that minimal and clear visualizations are often superior to everything else.\n\n\n\n\n\n\nSide Note\n\n\n\nTo get on my little soap box for a moment, I think that everyone who wants to create good visualizations should read Tufte (2001) at some point. Not because you should follow everything he says, but simply to raise awareness for some of the issues in data communication. Don’t worry, the book isn’t that long and it features a whole range of pretty images. :)"
  },
  {
    "objectID": "files/R_ggplot.html#special-use-cases-and-tricks",
    "href": "files/R_ggplot.html#special-use-cases-and-tricks",
    "title": "3  Beautiful data visualizations using ggplot2",
    "section": "Special use cases and tricks",
    "text": "Special use cases and tricks\n\nSub-plots based on variables\nUsing facet_grid() (or the less strict facet_wrap()), you can create subgraphs based on variables in your data set. That way, you could for example compare value distributions between different points in time. This is another way to display additional data without visual clutter as we’ve seen it in the above image. Based on your specifications, you can enter up to two variables to build subplots out of, using the formula facet_grid(verticalVariable ~ horizontalVariable) - however, you can leave one argument empty, if you just want one variable to control the split: facet_grid( ~ horizontalVariable):\n\n# facet_wrap based on year\nmpg %&gt;% mutate(cyl = as.factor(cyl)) %&gt;%\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_smooth(colour = \"dark gray\", fill = \"light gray\") + geom_point(aes(colour = cyl)) + \n  labs(title = \"Engine size - Miles/Gallon plot for different cars\",\n       subtitle = \"plotted in ggplot2\",\n       x = \"Engine size (litre)\", y = \"Miles/Gallon\", colour = \"# of cylinders\") + \n  facet_wrap(.~year)\n\n\n\n# facet_grid based on # of cylinders and year - notice empty fields for 1999 and 5 cyl\nmpg %&gt;% mutate(cyl = as.factor(cyl)) %&gt;%\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_smooth(colour = \"dark gray\", fill = \"light gray\") + geom_point(aes(colour = cyl)) + \n  labs(title = \"Engine size - Miles/Gallon plot for different cars\",\n       subtitle = \"plotted in ggplot2\",\n       x = \"Engine size (litre)\", y = \"Miles/Gallon\", colour = \"# of cylinders\") + \n  facet_grid(cyl~year)\n\n\n\n\n\n\n\n\n\n\nSide Note\n\n\n\nIn a case like this one, it would probably better not to use global axes, in order to better see differences within groups at the cost of visual differences between groups. to achieve this, you can set a scales parameter inside facet_... to “free_x”, “free_y” or “free” (both).\n\n\n\n\nDifferent axes in one plot\nThis is a niche case you may or may not encounter eventually, but I’ve had to deal with it twice and have been annoyed every time - which means I write this mostly for myself, so I can easily find it again.\nAs mentioned in the beginning, axes in ggplot are calculated globally depending on your data - even if you plug in different data sources, the result is a single, global scale depending on the minimum of the smaller variable and the maximum of the larger variable. To display data on two different scales at the same time, a bit of annoying trickery is needed: You simply have to scale up the second variable so that it fits inside the scale of the first variable, add a second axis for this variable, and re-transform the labels on this axis back to the original size via a command like scale_y_continuous(sec.axis = sec_axis(~ . FORMEL)). In practice:\n\n# data frame with two y values and x value \"month\"\nclimate &lt;- data.frame(month = 1:12, \n                      temp = c(-4,-4,0,5,11,15,16,15,11,6,1,-3),\n                      precip = c(49,36,47,41,53,65,81,89,90,84,73,55))\n\nclimate %&gt;% mutate(precip = precip / 8) %&gt;% # recode precipitation to temp scale\n  ggplot(aes(x = month)) + \n  geom_col(aes(y = precip), fill = \"light blue\") + # add precipitation\n  geom_line(aes(y = temp), colour = \"red\", size = 1.5) + # add temperature\n  # now recode the secondary axis back to the original scale\n  scale_y_continuous(\"Temperature\", sec.axis = sec_axis(~ . * 8, name = \"Precipitation\")) + \n  labs(x = \"Month\", title = \"Climatogram for Oslo (1961-1990)\") + # add title\n  geom_hline(yintercept = 0) + theme_minimal() # toy around a bit more\n\n\n\n\n\n\nGoing even further beyond\nAs you can see, the possibilities ggplot offers are (nearly) endless! And if you add further R-packages to the mix, you can build plots that are even more insane. If you want to be inspired, have a look at this: https://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html\nIf you want to learn more, I encourage you to just toy around a bit with ggplot. Once you understand the core format and the underlying grammar, you’ll be able to generate great plots in no time. And if you’re ever stuck, the internet has a wealth of knowledge around solving specific issues, whatever they may be. For further reading on ggplot, I’d also encourage you to have a look at the ggplot2 webseite and the R-Cookbook for graphs. Oh and read Tufte (2001)!\n\nLast modified: 2023-08-24 14:45, R version 4.3.1\nSource data for this page can be found here.\n\n\n\n\nTufte, Edward R. 2001. The Visual Display of Quantitative Information, 2nd Ed. Graphics Press."
  },
  {
    "objectID": "files/R_gitsetup.html",
    "href": "files/R_gitsetup.html",
    "title": "4  Working With RStudio and Git(Hub)",
    "section": "",
    "text": "Why Git?\nHave you ever accidentally deleted a file and then not found a way to restore it? Have you ever overwritten some important detail in a document and not been able to recover it? Do these situations still haunt you in your dreams? It doesn’t have to be like that! Git is a type of version control for your machine, allowing you to manually set Checkpoints for your progress that you can restore at any time for the entire folder or individual files within it.\nGoing even further, GitHub is a online database where you can upload these checkpoints. While GitHub is the most popular repository, there are many others that build on Git or similar structures to offer version control of your files. Now you may ask yourself: “Why would I want to upload my personal projects to the internet?” Well, here are some of the arguments:"
  },
  {
    "objectID": "files/R_gitsetup.html#version-1-git-over-a-desktop-client",
    "href": "files/R_gitsetup.html#version-1-git-over-a-desktop-client",
    "title": "4  Working With RStudio and Git(Hub)",
    "section": "Version 1: Git over a desktop client",
    "text": "Version 1: Git over a desktop client\nIn this version, all the interactions with GitHub will be handled automatically by a chosen software, and you won’t have to worry about anything. While this can be very convenient, keep in mind that in this way version control only works with this client! Meaning that if you want to sync something not intended by the developers, you might be in for an annoying time.\nIf you want to go this way, there is a whole boatload of potential desktop clients to choose from. If you for example already use VS Code for other projects, there’s a Git integration built in and you’ll find plenty of resources online to set that up, as well as plenty of plugins to expand it. Going beyond VS Code, GitHub has it’s own desktop client that’s able to sync any folder on your device. However, the last time I used it, I found it to be very annoying and clunky. The better alternative in my view and the one I use pretty regularly is GitKraken. The Team behind GitKraken is also responsible for the VS Code GitLens extension if you want to upgrade its capabilities."
  },
  {
    "objectID": "files/R_gitsetup.html#version-2-git-on-your-system-and-in-rstudio",
    "href": "files/R_gitsetup.html#version-2-git-on-your-system-and-in-rstudio",
    "title": "4  Working With RStudio and Git(Hub)",
    "section": "Version 2: Git on your system and in RStudio",
    "text": "Version 2: Git on your system and in RStudio\n\nStep 1: Installing Git\nAs mentioned previously, GitHub is only a web service for hosting you checkpoints and data. To communicate with GitHub, you can use a range of standardized commands and operations made available via a software called Git. Unfortunately (and this is the reason why desktop clients exist), Git is code-only and requires a Unix-terminal to function properly - which means Windows users have to jump through a few hoops when compared with everyone else.\n\nGit on Linux/Unix\nBased on your chosen distro, Git can easily be installed via package managers or built from source. For an installation overview for many of the more common distros see: https://git-scm.com/download/linux\n\n\nGit on MacOS\nIf you’re lucky, Git might already be installed on your machine from the get-go. To check if this is the case, simply open the terminal app and enter git --version. If a version number is displayed, git is installed on your machine - and if not, MacOS should ask you if it should install it now.\n\n\nGit on Windows\nWindows - unlike the other two options - does not have built-in Unix support, which means we also have to install a Unix terminal. Fortunately, Git comes with a built-in terminal (Git Bash) if you install it from the official website\n\n\n\n\n\n\nImportant\n\n\n\nGit will ask you during installation for a standard editor. In principle this choice shouldn’t matter, as that editor will only be used in case of errors, which you shouldn’t encounter when using Git through RStudio or desktop clients. Still, if you don’t know what you’re doing and have never heard of VI or VIM, it’s probably best to switch this to something like Nano or Notepad++ (if installed). All other installation steps can be left as default for normal use.\n\n\n\n\n\nStep 2: Git and RStudio\nAfter you install Git, RStudio should automatically detect it. To check, you can go to Tools -&gt; Global Options -&gt; GIT/SVN and see if it is listed there. If it isn’t listed there, you can manually add it by specifying the path: yourGitFolder/bin/git.exe. Restarting RStudio might also lead to a Git detection, especially if RStudio was opened during the Git installation process.\n\n\nStep 3: Configuring Git and GitHub\nAll the following steps can be done via the previously installed Git Bash terminal - however, this is (in my view) an unintuitive and error-prone process for casual users. Luckily, there is a way to configure Git in a more user-friendly way using R’s usethis package. After installing and loading usethis, you can open Git’s configuration directly using the edit_git_config command. Enter your name and the mail address of your GitHub account as follows:\n[user]\n    name = Your Name\n    email = github@mail-adress.com\n\n\n\n\n\n\nSide Note\n\n\n\nThe name you set here can be anything you like - however, keep in mind that it will appear whenever you upload something to GitHub from this device. You could for example give a name like Paul work laptop, to easily track which device made the changes.\n\n\nAfter this step, Git is ready to serve as a local version control. However, to sync your changes with GitHub, one more step of authentication is needed - after all, if it were only about name and mail address, anyone could commit changes in your name.\nLuckily, the usethis package can help us here once again: Running the function create_github_token() should open up the correct GitHub website to create your own so-called Personal Access Token. Here, you can also specify whether this token should only be active for a limited time (useful when working on other people’s machines) or what privileges this machine should have (touch this if you know what you’re doing, otherwise defaults should be fine). After completing this step, GitHub should present you with a token of the format ghp_....\nNote down this token somewhere, as you will never see it again once you close the site!\nTo set this token on your machine, go back to R and run the function gitcreds::gitcreds_set() (installed alongside usethis) and enter the token you just created. Theoretically, everything should be set up - you can check that yourself by running git_sitrep(). The big advantage of this is that Git is now globally configured and associated with your GitHub account, no matter what program you want to use on your machine - if it has Git or GitHub functionality, it should automatically detect your configurations.\nCongratulations! You should now (hopefully) have everything set up and ready to use version controlling and GitHub! In the next step, we’ll be looking at actually working with Git inside RStudio, as there is a lot of neat functionality built-in to take work off of you.\nIf you want to know more or take a deep dive on using R and Git - or if you encounter any problems that require a more thorough explanations - I recommend you have a look at https://happygitwithr.com/\n\nLast modified: 2023-08-24 13:13, R version 4.3.1\nSource data for this page can be found here."
  },
  {
    "objectID": "files/R_gituse.html",
    "href": "files/R_gituse.html",
    "title": "5  Using Git(Hub) in RStudio",
    "section": "",
    "text": "Starting a project\nTo have Git integration work from inside RStudio, it is strictly necessary to work inside an RStudio project rather than just a loose collection of code files scattered around your machine. This is because RStudio seems to treat the .Rproj file as an anchor point to build the file management around. While there are many ways to start a project, I want to highlight two different ways of doing things - although both boil down to the same method in the end.\nNow that you’ve opened your Git-synced project in RStudio, you might have already noticed something new: The Environment tab (usually top right) features a new tab simply labeled Git. When working with Git in RStudio, this tab is where all the magic happens - and everything that you otherwise would have to execute manually via the aforementioned Unix-terminal. Don’t be scared, but I will now show you a graphic visualizing the basic working steps in Git that I stole from Reddit:\nYou should already know many of the areas mentioned in this image, although maybe not by this name: The remote branch is the repo saved on GitHub, while the working branch is the file structure on your current machine. The other layers in between are what makes Git so powerful for version control (and so irritating in the beginning). Here’s how it works on a basic level:\nNow, if you’ve already made some changes to your new R project, you might notice that things start to appear inside the git-tab un RStudio. Based on the type of change, you should see a coloured symbol appear in the “Status” column: ?(New file), A(dded), M(odified), D(eleted) and R(enamed) will probably be the ones you’ll encounter most frequently. This window is RStudio’s pendant to the staging area I just mentioned - here, files are being prepared for a git synchronization. What the command git add does in the image above can be achieved here by clicking the check box:\nTo commit your selected files, you simply have to click the aptly named “Commit” button, leave an informative commit message as to what you did and why (so you know what happened when you look back in a few weeks/months/years) in the now open window, and then press “Commit” there as well.\nCongratulations! You now know how to use Git for version control! All that remains now is syncing your files with GitHub - something RStudio directly lets you know by complaining that your local branch is ahead of GitHub (here called origin/main) in it’s update history. To rectify this, simply press the green, upwards pointing arrow. In the opposite situation, where GitHub is further ahead than your local machine, RStudio would still complain, and you would pull by pressing the blue, downwards pointing arrow."
  },
  {
    "objectID": "files/R_gituse.html#new-project-that-started-on-github",
    "href": "files/R_gituse.html#new-project-that-started-on-github",
    "title": "5  Using Git(Hub) in RStudio",
    "section": "New project that started on GitHub",
    "text": "New project that started on GitHub\nThis in my view is the cleanest way of organizing version control, as much of the setup headaches get handled automatically for you:\n\nGo on GitHub and press the nice + button at the top to create a new repository\nOpen your newly created repository and press the green Code button at the top. Copy the web address displayed here\nOpen RStudio, start a new project (File -&gt; New Project), select Version Control -&gt; Git and enter the link you copied into the Repository URL field.\n\n\n\n\n\n\n\nSide Note\n\n\n\nTo keep things organized, I highly recommend selecting a dedicated folder for coding projects on your machine: If you input this folder at Create project as subdirectory of, RStudio will remember this and automatically select it the next time you generate a new project.\n\n\n\n\n\n\n\nThe big advantage of doing things this way is that the selected GitHub repository will be seen as the origin without needing manual setup. In this way, the project should immediately be usable, without having to worry about manually pushing or pulling files. If there are already files in your chosen repository, these will also automatically be downloaded and made available locally."
  },
  {
    "objectID": "files/R_gituse.html#preexisting-local-project",
    "href": "files/R_gituse.html#preexisting-local-project",
    "title": "5  Using Git(Hub) in RStudio",
    "section": "Preexisting local project",
    "text": "Preexisting local project\nDo you already have some old project lying around that you want to update and share and/or save on GitHub? Then this is the step for you! The core idea in this step is the same as before: We follow the instructions above to generate an (empty) repository and generate it locally as a new project. The trick with this approach is that you can now go ahead and - after opening the project’s folder in a file manager of your choice - simply copy all your old files into this new folder. RStudio’s Git integration will recognize these files as new to the project, and you will be able to work with them as if you had just created them inside the project."
  },
  {
    "objectID": "files/R_gituse.html#branches-more-control-over-your-project",
    "href": "files/R_gituse.html#branches-more-control-over-your-project",
    "title": "5  Using Git(Hub) in RStudio",
    "section": "Branches: More control over your project",
    "text": "Branches: More control over your project\nWhen you start a new project, you end up with one linearly developing history of changes, usually called a main branch (or “master” if following older conventions). However, it might not always be a good idea to work inside this main branch. For example if you’re only testing features and you’re not yet sure if they make it into the final project (or if they are horribly unstable), it might not be a good idea to include them in your main code database where they might ruin stuff or at the very least fill up your change history. Another case would be if you wanted to try and compare multiple different approaches to the same problem - you can’t really have both in the same file at the same time usually, as they are exclusive.\nLuckily, Git’s designers have thought of this and introduced the concept of “branches”: versions of your code that “split off” from the main branch and can develop in differing directions, allowing you to try out all the wildest ideas without ruining your project. For a practical use case, as I’ve mentioned before, ths website updates automatically whenever I commit something to the underlying repository. Now, I don’t want this to happen any time I make and commit some minor change, which is why I actually commit to a different branch called “indev” - and once I’m satisfied with my progress, I simply carry over all my changes to the main branch in one fell swoop.\n\n\n\n\n\n\nSide Note\n\n\n\nEven if you’re not dealing with these kinds of issues, it is probably always best to work with a separate testing branch, and NEVER commit untested code directly to the main branch - who knows what you might break in the process …\nTo make this easier to remember, if you open GitHub, you should see a message complaining that your main branch is unprotected. Setting the option to at least require pull requests (see below) is probably a good idea.\n\n\nWhen working in R, I found it easiest to employ the following workflow for new branches:\n\ncommit all outstanding changes to the branch you want to branch off from\ncreate a new branch on GitHub\nPull in GitHub. Since you’re up-to-date, no files should be overwritten, but the new branch should be detected. You can now switch local branches inside the Git tab (where it says “main” in the image above), and all changes should automatically be attributed to this branch from now on."
  },
  {
    "objectID": "files/R_gituse.html#forks-whats-yours-is-mine",
    "href": "files/R_gituse.html#forks-whats-yours-is-mine",
    "title": "5  Using Git(Hub) in RStudio",
    "section": "Forks: What’s yours is mine",
    "text": "Forks: What’s yours is mine\nIf you’ve ever taken a stroll through the wonderful world of open-source software or had the time to look at GitHub’s “Explore” section, you might have noticed something: There is a whole boat load of complete, incomplete and abandoned software available out there. In fact, if you’re looking to solve a specific problem, you might find that someone has already started working on it - or completed a somewhat similar project that just needs some slight tweaking for your use case. This is where forks come in.\nForks are basically just like branches, with the main difference being that you’re not creating a new branch inside the same repository, but instead creating a new repository based on someone else’s work. That way, you start out with all the work they’ve already committed and can then go on to tweak it to your liking. For a practical example, the engine underlying the Firefox web browser has almost 2.000 forks from users modifying security settings to their liking or building their own web browsers from the provided baseline (not an endorsement, just an example)."
  },
  {
    "objectID": "files/R_gituse.html#merging-why-cant-we-be-friends",
    "href": "files/R_gituse.html#merging-why-cant-we-be-friends",
    "title": "5  Using Git(Hub) in RStudio",
    "section": "Merging: Why can’t we be friends?",
    "text": "Merging: Why can’t we be friends?\nNow that you’ve substantially improved someone else’s code (or toyed around in a separate branch and want to update the main branch), another step is necessary: merging the changes. If you’re the owner of both the original (main in my case) and the new and improved branch (indev in my case), this is not an issue and can be done with relative ease. Out of convenience, I will demonstrate this using GitHub, but as before, you can also use Git via terminal.\nTo merge two branches via GitHub, go to your project’s repository and in the “Pull requests” tab click on New pull request. Now select the new branch, and you’ll land on a comparison website. It should have already selected a comparison between indev and main at the top (or however you called your branches) and show you the changes between both branches. If you toy around with this, you can see that you can merge any branches in your repository - you aren’t limited to constantly overwriting your main branch.\n\n\n\n\n\n\nSide Note\n\n\n\nThis allows for more complex testing structures. You could for example run a “main” branch with working code, an “indev” branch to develop new features that branches off from “main” and an “unstable” branch off of “indev” that tests brand new features. Once you’re reasonably certain about your code, you could then merge “unstable”’s changes into “indev” for further testing, before deploying them to “main”.\n\n\nIf nothing went horribly wrong in your branch management, you should also be presented with a big green “New pull request” GitHub should automatically open a overview site for the new pull request, where you simply have to approve the changes to incorporate them to the main branch (or whichever branch you want to merge to). This is also where requests from other users that worked on your code will appear for your approval (and where your pull requests will appear on other users’ projects.\nAs before, if you’re still unsure about how things work or want to learn more about the possibilities Git and R offer, I recommend you look at: https://happygitwithr.com/index.html\n\nLast modified: 2023-08-24 14:56, R version 4.3.1\nSource data for this page can be found here."
  },
  {
    "objectID": "files/references.html",
    "href": "files/references.html",
    "title": "References",
    "section": "",
    "text": "Field, Andy P., Jeremy Miles, and Zoë Field. 2012. Discovering\nStatistics Using R. London ; Thousand Oaks, Calif:\nSage.\n\n\nTufte, Edward R. 2001. The Visual Display of Quantitative\nInformation, 2nd Ed. Graphics Press.\n\n\n\nLast modified: 2023-08-22 15:06, R version 4.3.1\nSource data for this page can be found here."
  }
]